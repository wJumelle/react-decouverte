# üöÄ D√©couverte de React

D√©couverte de React en suivant la [**documentation fran√ßaise**](https://fr.reactjs.org/docs/getting-started.html).
Version de React lors de la d√©couverte : **v16.13.1**.

==> Lien vers [**Glossaire React**](https://fr.reactjs.org/docs/glossary.html)

==> Lien vers [**Les fondamentaux**](https://fr.reactjs.org/docs/hello-world.html)

## Sommaire
1. [**Objectifs**](#objectifs)
2. [**Introduction**](#introduction)
3. Guide √©tape par √©tape : [**Introduction √† JSX**](#introduction-√†-jsx)
4. Guide √©tape par √©tape : [**Le rendu des √©l√©ments**](#le-rendu-des-√©l√©ments-doc)
5. Guide √©tape par √©tape : [**Composants et props**](#composants-et-props-doc)
6. Guide √©tape par √©tape : [**√âtat et cycle de vie**](#√©tat-et-cycle-de-vie-doc)
7. Guide √©tape par √©tape : [**G√©rer les √©v√©nements**](#g√©rer-les-√©v√©nements-doc)

## Objectifs
Les objectifs √† la suite de la d√©couverte de la documentation vont √™tre simple : 
* Cr√©er une petite application React pour se faire la main sur l'outil ([**tutoriel pratique de React : construction d'un morpion**](https://fr.reactjs.org/tutorial/tutorial.html))
* Cr√©er un stater webpack avec React (pour mise en place de la compilation, du HMR etc)
* ? potentiellement cr√©er un projet un peu plus consistant avec React afin de le mettre en avant sur le portfolio

## Introduction
**React** est une biblioth√®que JavaScript pour la construction d'interface utilisateur (UI).
A quoi sert React ? Qu'est ce que c'est ? Comment cela fonctionne ? 

React est une biblioth√®que **d√©clarative**, gr√¢ce √† laquelle il est simple de cr√©er des UI int√©ractives.  
Avec React nous devons d√©finir des vues simples pour chacun des √©tats possible de notre application, ainsi lorsque les donn√©es 
√©volueront, React se chargera de mettre √† jour, de fa√ßon optimale, les composants impact√©s par cette √©volution.  
Les **vues d√©claratives** rendent le code plus simple √† analyser en vue d'un potentiel d√©bogage. 

React est bas√© autour de la cr√©ation de **composants**.  
Ces composants devront √™tre autonomes et ainsi maintenir leur propre √©tat. En les assemblant nous pourrons alors obtenir une UI 
complexe.  
Ces composants √©tant √©crit en JavaScript, et non sous la forme d'un simple template HTML, nous pourrons facilement utiliser des donn√©es
complexes pour les irriguer et maintenir l'√©tat de ceux-ci hors du DOM. 

React est globalement une solution utilisable partout, que ce soit client-side ou server-side et m√™me sur des applications mobiles, grace √† 
[React Native](https://react-native.dev/).

Tous les composants React devront impl√©menter une m√©thode **render()** qui prend des donn√©es en entr√©es et retourne ce qui doit √™tre affich√© 
lorsque le composant est appel√©.  
Les donn√©es pass√©es au composant sont accessible dans la m√©thode render() via **this.props**.

```
class HelloMessage extends React.Component {
  render() {
    return (
      <div>
        Salut {this.props.name}
      </div>
    );
  }
}

ReactDOM.render(
  <HelloMessage name="Thierry" />,
  document.getElementById('hello-example')
);
```

De plus, les composants React peuvent maintenir un **√©tat local**, qui sera accessible via **this.state**.  
Lorsque cet √©tat varie la m√©thode render() est syst√©matiquement appel√©e, l'affichage du composant est alors automatiquement mis √† jour. 

```
class Timer extends React.Component {
  constructor(props) {
    super(props);
    this.state = { seconds: 0 };
  }

  tick() {
    this.setState(state => ({
      seconds: state.seconds + 1
    }));
  }

  componentDidMount() {
    this.interval = setInterval(() => this.tick(), 1000);
  }

  componentWillUnmount() {
    clearInterval(this.interval);
  }

  render() {
    return (
      <div>
        Secondes : {this.state.seconds}
      </div>
    );
  }
}

ReactDOM.render(
  <Timer />,
  document.getElementById('timer-example')
);
```

[**‚òù Retour en haut de page**](#-d√©couverte-de-react)
## Introduction √† JSX ([doc](https://fr.reactjs.org/docs/introducing-jsx.html))
```
const element = <h1>Bonjour, monde !</h1>;
```

Cette syntaxe n'est ni une cha√Æne de caract√®re ni du HTML √† proprement parl√©.  
C'est ce que l'on appelle du **JSX**, et c'est une **extension syntaxique de JavaScript**.  
Elle permet de d√©crire √† quoi doit ressembler un √©l√©ment de l'interface utilisateur (UI). Cela ressemble √† un language de balisage 
standard, mais il renferme toute la puissance du JavaScript !

JSX va produire des **√©l√©ments React** qui pourront √™tre retranscrit dans le DOM.

### Pourquoi le choix du JSX ?
Une interface utilisateur a toujours conditionn√©e les **logiques de rendu**, les **logiques de la gestion des √©v√©nements** √† la pr√©paration 
des donn√©es pour l'affichage, en passant par **l'√©volution de l'√©tat au fil du temps**.   

React a choisi d'assumer pleinement cet √©tat de fait et au lieu de s√©parer les "technologies", en mettant d'un c√¥t√© le **balisage** et de l'autre 
la **logique**, √† d√©cider de d'opter pour la fragmentation de son code avec comme unit√© les **composants**.  
Ces composants contiennent √† la fois, le balisage et la logique mais sont isol√©s les uns des autres. C'est ce que l'on appelle la [**s√©paration des pr√©occupations**](https://fr.wikipedia.org/wiki/S%C3%A9paration_des_pr%C3%A9occupations).

### L'Utilisation des expressions JavaScript dans JSX
L'une des features tr√®s int√©ressantes de l'usage du JSX est la **possibilit√© d'int√©grer dans le balisage des expressions JavaScript**, rendant 
ainsi notre balisage potentiellement dynamique. 
Ici, l'affichage variera en fonction d'une constante d√©termin√©e, mais nous pourrions imaginer que la variable *name* soit d√©finie par l'utilisateur.

```
const name = 'Wilfried JUMELLE';
const element = <h1>Bonjour, {name}</h1>;

ReactDOM.render(
  element,
  document.getElementById('app')
);
```

Comme nous avons acc√®s aux expressions JavaScript, cela va de soit que nous avons acc√®s √† toutes fonctions d√©finis dans notre code.  
Ainsi nous pourrions imaginer un travail de formatage autour du nom complet en unissant les variables *firstName* et *lastName* au sein d'une 
fonction.

Lorsque le JSX devient complexe √† lire, il est important de ne pas h√©siter √† le **d√©couper en plusieurs lignes**. Cela augmente la lisibilit√© du 
code sans pour autant le cass√©. Il est recommand√© d'encadrer le JSX multilignes par des parenth√®ses, afin d'√©viter l'insertion de ; automatique.

```
function formatName(u) {
    return u.firstName + ' ' + u.lastName;
}

const user = {
    'firstName': 'Wilfried',
    'lastName': 'Jumelle'
};

const element = (
    <h1>
        Bonjour, {formatName(user)} !
    </h1>
);

ReactDOM.render(
  element,
  document.getElementById('app')
);
```

Au final, apr√®s compilation les expressions JSX deviennent de simples **appels de fonctions JavaScript**, dont l'√©valuation renvoie 
des objets JavaScript.  
Ce qui permet d'utiliser JSX √† l'int√©rieur d'**instructions conditionnels (if)** ou dans des **boucles (for)**, ou bien encore l'**affecter 
√† des variables**, l'accepter en **arguments de fonction** et le renvoyer depuis ces fonctions.

### Sp√©cifier des attributs en JSX
√Ä l'int√©rieur du JSX il est possible d'ajouter des **attributs HTML**.  
Cela peut se faire de 2 fa√ßons diff√©rentes : 
1. avec des **guillemets** pour sp√©cifier des attributs sous forme de cha√Æne de caract√®res 
2. avec des **accolades** pour sp√©cifier des attributs sous forme d'expressions JavaScript

Il ne faudra pas utiliser les deux en m√™me temps !

> ‚ùó JSX utilise la casse **camelCase** pour le nommage des propri√©t√©s. Ainsi, `tabindex` devient `tabIndex`.
> Autre particularit√©, le mot-cl√© `class` √©tant d√©j√† r√©serv√© en JavaScript, pour sp√©cifier l'attribut class il faudra utiliser 
> ``className``.

```
const element = (
    <div tabIndex="0" className="card">
        <img src={user.avatar} />
    </div>
);
```

### Explication du fonction de JSX
Le JSX repr√©sente au final des objets.  
En effet, lorsque Babel compile du JSX, il produit des appels √† **React.createElement()**. 

Ainsi, les deux codes suivants sont identiques : 
```
const element = (
  <h1 className="greeting">
    Bonjour, monde !
  </h1>
);
```

```
const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Bonjour, monde !'
);
```

Comme dit plus haut, ce que fait la m√©thode **React.createElement()** est simple : elle cr√©√© un objet, que l'on appelle **√©l√©ment React**, 
apr√®s avoir effectu√© quelques v√©rifications de s√©curit√© et de propret√©.  
Nous obtiendrons donc approximativement l'objet suivant : 

```
// Remarque : cette structure est simplifi√©e
const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Bonjour, monde !'
  }
};
```

Les √©l√©ments React sont des **descriptions** de ce que l'on veut voir appara√Ætre √† l'√©cran. React lit l'ensemble de ces objets et les 
utilise pour construire le DOM et le maintenir √† jour. 

### JSX et la s√©curit√©
Une autre feature int√©ressante du JSX √©tant la **v√©rification** et l'**√©chappement des donn√©es** avant d'effectuer le rendu par React.  
Ceci √©tant fait, on peut donc se servir des donn√©es provenant d'un input en affichage, sans craindre les probl√®mes d'injections (XSS par exemple).

## Le rendu des √©l√©ments ([doc](https://fr.reactjs.org/docs/rendering-elements.html))
Les √©l√©ments sont les **blocs √©l√©mentaires** d'une application React. **Un √©l√©ment n'est pas un composant** !  
Les √©l√©ments sont la base m√™me des composants React. 

Les √©l√©ments React, contraitement aux √©l√©ments du DOM, sont peu co√ªteux √† cr√©er, car tr√®s basique dans leur conception.  
**React DOM** va se charger de mettre √† jour le DOM afin qu'il correspond aux √©l√©ments React cr√©√©s. 

### Afficher un √©l√©ment dans le DOM
Les applications d√©velopp√©es en React ont g√©n√©ralement un DOM natif tr√®s simple, qui est compos√© d'**un et unique noeud DOM "racine"**.  
C'est √† l'int√©rieur de ce noeud DOM "racine" que tout sera g√©n√©r√© par **ReactDOM**. 

Pour effectuer le rendu d'un √©l√©ment React √† l'int√©rieur d'un noeud DOM "racine", rien de plus simple : il suffit d'utiliser la m√©thode suivante. 
```
HTML
<div id="app"></div>

JS
const elem = <h1>Un super titre pour bien commencer mon application</h1>
ReactDOM.render(elem, document.getElementById('app'));
```

La m√©thode **ReactDOM.render()** prend 2 param√®tres : l'√©l√©ment √† g√©n√©rer √† l'int√©rieur du noeud "racine" et ce m√™me noeud "racine".  
==> [**Documentation de la m√©thode ReactDOM.render()**](https://fr.reactjs.org/docs/react-dom.html#render).

### Mettre √† jours un √©l√©ment d√©j√† affich√©
Les √©l√©ments React sont [**immuables**](https://fr.wikipedia.org/wiki/Objet_immuable), c'est √† dire qu'une fois cr√©√© ils ne peuvent plus √™tre 
modifi√©. Que ce soit, l'√©l√©ment lui-m√™me, ses enfants ou bien ses attributs.  
Pour imager les propos, un **√©l√©ment React c'est comme un screenshot d'un film √† un instant T**, l'√©l√©ment repr√©sente donc l'UI √† un point 
pr√©cis dans le temps. 

Avec nos connaissances actuelles, si l'on veut modifier cette UI, il faut donc cr√©er un nouvel √©l√©ment (ou bien le re-g√©n√©rer) et le passer 
de nouveau √† la m√©thode ReactDOM.render().

> üí° En pratique, la plus part des applications React n'appellent la m√©thode ReactDOM.render() qu'une seule fois au sein de leur code. 
> C'est l√† qu'intervient les **composants React**.

### L'intelligence de React autour de la mise √† jours des contenus
React optimise les op√©rations qu'il doit effectuer sur le DOM en **comparant l'√©tat pr√©c√©dent et l'√©tat qu'on lui transmet**.  
De cette comparaison il va observer les variations et appliquer la mise √† jour uniquement l√† o√π cela est n√©cessaire. 
Et cela se produit m√™me si l'on demande √† React de re-g√©n√©rer l'ensemble du noeud "racine". 

```
function tick() {
  const element = (
    <div>
    <h1>Bonjour, monde !</h1>
    <h2>Il est {new Date().toLocaleTimeString()}.</h2>
    </div>
  );
  ReactDOM.render(element, document.getElementById('app-elements'));
}

tick();
setInterval(tick, 1000);
```

Le code ci-dessus va appeler la m√©thode ReactDOM.render() toutes les secondes, se faisant, il va re-g√©n√©rer le noeud racine de l'application 
toutes les secondes.  
Pourtant, si l'on observe la console de notre navigateur, nous pourrons observer que seul le noeud `<h2>` est r√©√©crit √† chaque appel. 

[**‚òù Retour en haut de page**](#-d√©couverte-de-react)
## Composants et props ([doc](https://fr.reactjs.org/docs/components-and-props.html))
Qu'est ce qu'un composant React ? Un composant React c'est tout simple une brique de l'interface utilisateur. C'est qui va nous permettre 
de subdiviser cette interface en √©l√©ment totalement ind√©pendants et r√©utilisables. Chacun de ces √©l√©ments pourra donc √™tre consid√©r√©e de 
mani√®re isol√©e. 

==> [**Documentation d√©taill√©e des composants**](https://fr.reactjs.org/docs/react-component.html)

Le concept des composants est simple, nous avons des **propri√©t√©s (props) en entr√©e** et en **sortie nous obtenons un √©l√©ment React**.

### Fonctions composants et composants √† base de classe
Il existe **deux fa√ßons diff√©rentes** de d√©finir des composants en React.  
1. via la cr√©ation d'une fonction JavaScript = fonctions composants
2. via le cr√©ation d'une classe ES6

La m√©thode la plus simple reste la premi√®re, c'est √† dire celle qui consiste √† √©crire une fonction JavaScript pour produire un composant React. 
La fonction suivante est un composant React valide car elle accepte en arguments des propri√©t√©es props et retourne un √©l√©ment React.

```
function Welcome(props) {
  return <h1>Bonjour, {props.name}</h1>
}
```

Voici la version de la fonction ci-dessus √©crite √† l'aide d'une classe ES6.

```
class Welcome extends React.Component {
  render() {
    return <h1>Bonjour, {this.props.name}</h1>;
  }
}
```

Ces deux composants sont **√©quivalents du point de vue de React**, nous obtiendrons au final le m√™me √©l√©ment React.

### Produire le rendu d'un composant
Jusqu'ici nous nous sommes servi de la m√©thode ReactDOM.render() uniquement pour affichage des √©l√©ments React repr√©sentant des balises du DOM. 
ReactDOM.render() peut aussi afficher des √©l√©ments React repr√©sentant des composants d√©finis par l'utilisateur.  
Lorsque React va rencontrer un √©l√©ment React de type composant, il va **transmettre les attributs JSX et les enfants √† ce composant** sous la 
forme d'un objet unique : **props**.

```
function Welcome(props) {
  return <h1>Bonjour, {props.name}</h1>;
}

const elemComposants = <Welcome name="Wilfried" />;
ReactDOM.render(
  elemComposants,
  document.getElementById('app-composants')
);
```

Voici ce qui se produit dans notre contexte : 
1. la m√©thode ReactDOM.render() est appel√© avec en param√®tre l'√©l√©ment *elemComposants* qui est un √©l√©ment React de type *componsants* `<Welcome />.` 
2. React appelle le composant `<Welcome />` et lui transmets les props {name = 'Wilfried'}
3. le composant `<Welcome />` retourne l'√©l√©ment React `<h1>Bonjour, {props.name}</h1>` o√π {props.name} vaut Wilfried.
4. ReactDOM met √† jours efficacement le DOM pour correspond √† la valeur retourn√©e par le composant `<Welcome />`

> üí° Petit point autour des r√®gles de nommages : React consid√®re les composants commen√ßant par une minuscule comme √©tant des balises du DOM. 
> Par ex : `<div />` sera per√ßu comme une balise HTML `<div></div>`, tandis que `<Welcome />` repr√©sente lui un composant React. 
> Autre particularit√© lors de l'appel d'un composant, il faut s'assurer que ce composant soit bien disponible et pr√©sent dans la port√©e 
> courante ! 
> Pour plus d'information autour de cette convention de nommage, vous pouvez lire la documentaiton [**JSX en profondeur**](https://fr.reactjs.org/docs/jsx-in-depth.html#user-defined-components-must-be-capitalized)

### Composition des composant
Comme dit plus haut, la plus part des applications r√©centes ne font appel qu'une seule fois √† la m√©thode ReactDOM.render(), comment pouvons-nous 
expliquer cela ? 
Tout simplement car un composant peut faire **r√©f√©rence** √† d'autres composants. Ce qui nous permet par exemple, de mettre en place un composant 
`<Formulaire />` dans lequel nous ferons r√©f√©rences √† plusieurs composants `<Champ />`.
Ce qu'il faut comprendre, c'est que dans React tous les √©l√©ments de l'interface utilisateur sont exprim√©s par des composants.

En r√®gle g√©n√©rale, les nouvelles applications React comporteront un seul et unique composant `<App />` √† la racine. Ce sera ce composant que l'on 
g√©n√©rera via la m√©thode ReactDOM.render().

```
function Welcome(props) {
  return <h1>Bonjour, {props.nam} !</h1>
}

function App() {
  return (
    <div>
      <Welcome name="Wilfried" />
      <Welcome name="Elodie" />
      <Welcome name="Gwendoline" />
    </div>
  )
}

ReactDOM.render(
  <App />,
  document.getElementById('app-composantsApp')
);
```

### Extraire des composants
Lorsqu'un composant devient trop important et qu'il devient complexe √† lire et √† maintenir, c'est que l'on peut mieux faire ! Comment ?  
En cherchant √† **scinder ce composant en plusieurs briques distinctes** que l'on pourra r√©utiliser s√©par√©ment du contexte de ce composant.  

Il est tr√®s important de toujours √©valuer la taille des composants que l'on cr√©√© mais aussi la r√©utilisabilit√© de certains √©l√©ments de ce composant.  
Si un √©l√©ment intervant dans un composant est red√©fini dans un, deux ou trois autres composants, c'est que l'on peut extraire cette brique pour en faire 
un composant isol√©.

Prenons ici exemple sur un composant `<Comment />` dont le but serait d'afficher un commentaire dans un r√©seau social. 

```
function Comment(props) {
  return (
    <div className="Comment">
      <div className="UserInfo">
        <img className="Avatar"
          src={props.author.avatarUrl}
          alt={props.author.name}
        />
        <div className="UserInfo-name">
          {props.author.name}
        </div>
      </div>
      <div className="Comment-text">
        {props.text}
      </div>
      <div className="Comment-date">
        {formatDate(props.date)}
      </div>
    </div>
  );
}
```

A la premi√®re lecture on se rend compte de deux choses : nous avons des informations sur le message et sur son auteur.  
Les informations sur l'auteur pourraient √™tre r√©utilis√©s ailleurs, par exemple lors de l'affichage de son profil.  
Nous allons donc chercher √† extraire ce composant afin de l'isoler, comme ceci : 

```
Etape 1 : Cr√©ation du composant <Avatar />
function Avatar(props) {
  return (
    <img className="Avatar"
      src={props.user.avatarUrl}
      alt={props.user.name}
    />
  );
}

Etape 2 : Cr√©ation du composant <UserInfo />
function UserInfo(props) {
  return (
    <div className="UserInfo">
      <Avatar user={props.user} />
      <div className="UserInfo-name">
        {props.user.name}
      </div>
    </div>
  );
}

Etape 3 : Update du composant <Comment />
function Comment(props) {
  return (
    <div className="Comment">
      <UserInfo user={props.author} />
      <div className="Comment-text">
        {props.text}
      </div>
      <div className="Comment-date">
        {formatDate(props.date)}
      </div>
    </div>
  );
}
```

### Les props sont en lecture seul
Point tr√®s importants, que nous d√©clarions les composants √† l'aide d'une fonction ou d'une classe ES6, ce dernier **ne doit jamais modifier ses propres props**.  
**‚ùó Tout composant React doit agir comme une fonction pure vis-√†-vis de ses props.**

[**‚òù Retour en haut de page**](#-d√©couverte-de-react)
## √âtat et cycle de vie ([doc](https://fr.reactjs.org/docs/state-and-lifecycle.html))

==> [**Documentation de la r√©f√©rence API des composants**](https://fr.reactjs.org/docs/react-component.html)

Dans l'exemple pr√©c√©dent autour de l'horloge, nous avions vu que notre √©l√©ment √©tait mis √† jours √† l'aide d'un interval JavaScript 
mis en place qui toutes les X secondes appelait la fonction qui g√©n√©rait le JSX et effectu√©e l'appel √† la m√©thode ReactDOM.render(). 

Cette fa√ßon de faire n'est pas optimale, en effet, tout est dispers√© dans notre code et cela force √† isoler l'appel √† la m√©thode de 
rendu. Or nous l'avons vu pr√©c√©dement, il est souhaitable d'appeler cette m√©thode **qu'une seule fois** dans l'application.

Il va donc falloir trouver un autre moyen de concevoir notre composant, afin que celui-ci soit totalement **isol√©** et potentiellement 
**r√©utilisable**.  
Ce composant aura pour fonction de mettre en place son propre minuteur et de se mettre √† jour automatiquement. Il sera **ind√©pendant**. 

Ainsi, pour d√©buter ce travail, nous pouvons passer de ce code : 

```
function tick() {
  const element = (
    <div>
      <h1>Bonjour, monde !</h1>
      <h2>Il est {new Date().toLocaleTimeString()}.</h2>
    </div>
  );
  ReactDOM.render(
    element,
    document.getElementById('root')
  );
}

tick();
setInterval(tick, 1000);
```

√† celui-ci : 

```
function Clock(props) {
  return (
    <div>
      <h1>Bonjour, monde !</h1>
      <h2>Il est {props.date.toLocaleTimeString()}.</h2>
    </div>
  );
}

function tick() {
  ReactDOM.render(
    <Clock date={new Date()} />,
    document.getElementById('root')
  );
}

setInterval(tick, 1000);
```

Ici, on peut voir que le composant `<Clock />` n'est pour l'instant pas encore ind√©pendant. Ce que nous souhaiterions obtenir, serait 
plutot ceci : 

```
ReactDOM.render(
  <Clock />,
  document.getElementById('root')
);
```

Dans cette version, la m√©thode ReactDOM.render() n'est plus comprise dans l'intervale JavaScript. Cet interval va √™tre g√©r√© au niveau 
du composant, tout comme le rafraich√Æssement de son contenu. 

Pour impl√©menter √ßa, nous avons besoin d'ajouter un **√©tat local** au composant `<Clock />`.  
L'√©tat local est assez similaire aux props, mais est **priv√©** et compl√©tement contr√¥l√© par le composant.

### Convertir une fonction en classe
Pour convertir un composant fonctionnel en un composant de type classe, il suffit de faire quelques r√©ajustements.  
1. **Cr√©ation de la classe ES6** qui portera le nom de notre composant et qui **√©tendra React.Component**
2. **Cr√©er une m√©thode render()** dans laquelle on viendra d√©poser le code JSX
3. **Remplacer props par this.props**

Ce qui donne :
```
class Clock extends React.Component {
  render() {
    return (
      <div>
        <h1>√âtats et cycle de vie - format class</h1>
        <h2>Il est {this.props.date.toLocaleTimeString()}.</h2>
      </div>
    )
  }
} 
```

Ce faisant, la m√©thode ``render()`` du composant `<Clock />` sera appel√© √† chaque fois qu'une variation de ce composant sera 
d√©tect√©e par React. 
Tant que l'on exploite le rendu du composant `<Clock />` dans le m√™me noeud DOM "racine", une seule instance de la classe **Clock** 
sera utilis√©e. Ce qui va nous permettre d'utiliser les fonctionnalit√©s suppl√©mentaires suivantes : **l'√©tat local** et les m√©thodes de 
**cycle de vie**.

### Ajouter un √©tat local √† une classe
Il va de nouveau falloir suivre quelques √©tapes pour r√©ussir √† int√©grer la fonctionnalit√© d'√©tat local. 
1. **Modifier l'appel √† la variable** qui correspond √† la date : passer de `this.props.date` √† `this.state.date`
2. **Cr√©er le constructeur de notre classe** et y passer en param√®tre les **props**
3. **Supprimer l'initialisation de la date** dans l'appel au composant

Ce qui nous donne : 
```
class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = { date: new Date(); }
  }

  render() {
    return (
      <div>
        <h1>√âtats et cycle de vie - format class</h1>
        <h2>Il est {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    )
  }
}

function tick() {
  ReactDOM.render(
    <Clock />,
    document.getElementById('root')
  );
}

setInterval(tick, 1000);
```

> ‚ùó Les constructeurs de classe doivent toujours passer props en param√®tres. 
> ‚ùó A l'int√©rieur de ces m√™mes constructeurs nous devons toujours appeler le constructeur parent de notre classe en y passant 
> les props en param√®tres. Pour cela nous utilisons le mot-cl√© `super(props)` ([**doc MDN**](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Operators/super)).

### Ajouter des m√©thodes de cycle de vie √† une classe
Dans des applications avec de nombreux composants, il est primordiale de veiller √† optimiser les ressources utilis√©es par ces composants.  
Ainsi, si un compostant est d√©truit il faut lib√©rer les ressources qui lui √©taient associ√©es.  

Nous d√©sirons internaliser √† notre composant `<Clock />` la gestion et la mise en place du minuteur.  
Cette cr√©ation surviendra la premi√®re fois que notre composant sera ajout√© au DOM.  
Dans React on appelle cette phase **le montage**.

A l'inverse, lorsqu'un composant est d√©truit / supprim√© du DOM, on appelle cette phase **le d√©montage**. 
Au cours de cette phase de d√©montage, il faudra veiller √† la suppression du minuteur. 

Les phases de montage et de d√©montage sont "√©cout√©es" dans React par deux m√©thodes sp√©ciales : `componentDidMount()` et `componentDidUnMount()` 
pour le d√©montage.

Ce qui nous donne le code suivant : 

```
class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = { date: new Date() }
  }

  componentDidMount() {
    this.intervalID = setInterval(
      () => {
        this.setState({ date: new Date() })
      }, 1000
    );
  }

  componentWillUnmount() {
    clearInterval(this.intervalID);
  }

  render() {
    return (
    <div>
      <h1>√âtats et cycle de vie - format class cycle de vie</h1>
      <h2>Il est {this.state.date.toLocaleTimeString()}.</h2>
    </div>
    )
  }
}

ReactDOM.render(
  <Clock />,
  document.getElementById('app-etatsCycle')
);
```

Pour r√©sumer ce qu'il se produit : 
1. Le composant `<Clock />` est pass√© √† la m√©thode `ReactDOM.render()`. Se faisant React appelle le constructeur du composant et 
initialise ainsi `this.state` en y ajoutant la valeur de la date √† laquelle le constructeur a √©t√© appel√©
2. React appelle finalement la m√©thode `render()` du composant `<Clock />` afin de d√©couvrir ce qu'il faut afficher √† l'√©cran. React 
met ensuite √† jour le DOM pour correspondre √† la sortie re√ßue par le composant
3. React d√©tecte le montage du composant `<Clock />` et d√©clenche sa m√©thode de cycle de vie `componentDidMount()` cr√©ant ainsi 
l'intervale qui toute les secondes va mettre √† jour la valeur de `this.state` √† l'aide de l'appel √† la m√©thode `this.setState()`, en 
y passant en param√®tre un objet correspondant √† la nouvelle date. C'est gr√¢ce √† l'appel de cette m√©thode que React sait que l'√©tat du 
composant a chang√©, en cons√©quence React appelle la m√©thode `render()` du composant afin de d√©terminer ce qui devrait s'afficher √† 
l'√©cran avec ce nouvel √©tat. React va faire la comparaison de la sortie retourn√©e par le composant `<Clock />` et ce qui est 
actuellement dans le DOM et d√©tecter une diff√©rence. React met alors le DOM √† jour en accord avec le nouveau rendu.
4. Si le composant `<Clock />` est retir√© du DOM, alors la m√©thode de cycle de vie `componentDidUnmount()` du composant sera appel√©e 
par React pour que le minuteur soit arr√™t√© et l'intervale supprim√©. 

### Utiliser l'√©tat local correctement 
Il y a trois choses √† savoir √† propos de la m√©thode `setState()` :
1. Il ne faut pas modifier l'√©tat directement `this.state.date = new Date()` n'est pas correct, √† la place il faut faire 
`this.setState({ date: new Date() })`. Le seul endroit o√π l'on peut affecter l'objet `this.state` c'est √† l'int√©rieur du constructeur.
2. Les mises √† jours de l'√©tat peuvent √™tre asynchrones. Ce faisant, il ne faut pas se baser sur les valeurs de `this.state` et 
`this.props` pour calculer la prochaine valeur de l'√©tat √† venir. Pour rem√©dier √† cela, il existe une deuxi√®me version de la m√©thode 
`this.setState((state, props) => { counter: state.counter + props.increment })` qui est bas√© sur le passage en param√®tre d'une fonction 
(qui peut √™tre fl√©ch√©e ou non) √† la place d'un objet. Cette fonction poss√®de 2 arguments : l'√©tat pr√©c√©dent du composant et les props 
au moment de la mise √† jour.
3. Les mises √† jours de l'√©tat sont fusionn√©es. Cela veut dire que lorsque l'on poss√®de un √©tat `this.state` qui contient plusieurs 
objets, lors de l'appel √† la m√©thode `this.setState()` nous ne sommes pas oblig√© d'indiquer tous les objets inclus dans l'√©tat. Nous allons pouvoir sp√©cifier uniquement l'objet qui varie.  

Voici un exemple pour d√©montrer le fonctionnement expliquer autour du troisi√®me point : 
```
[...]
constructor(props) {
  super(props);
  this.state = {
    posts: [],
    comments: []
  };
}

componentDidMount() {
  fetchPosts().then(response => {
    this.setState({
      posts: response.posts
    });
  });

  fetchComments().then(response => {
    this.setState({
      comments: response.comments
    });
  });
}
```

La fusion n'est pas **profonde**, ce qui fait que `this.setState({comments})` laissera `this.state.posts` intacte, mais remplacera 
compl√©tement `this.state.comments`.

### Les donn√©es descendent
L'arborescence des composants React d'une application pourrait √™tre vu comme une grande cascade d'eau, dont l'eau coulerait du haut vers le bas.  
Le haut de la cascade repr√©sente les premiers composants, ceux qui englobent, le bas repr√©sent leurs descendants. 

Nul parent ou enfant peut savoir si un certain composant est √† √©tat ou non, et ceci m√™me si l'un des composants descend de l'autre. Et il ne 
devrait pas avoir √† se soucier s'il est d√©fini par une classe ou par une fonction.  
Rappelons qu'un √©l√©ment d√©finie par une fonction ne peut avoir √©tat, car celui-ci ne contient pas de constructeur pour initialis√© son √©tat. 

C'est pourquoi on dit souvent en React que l'√©tat est **local** ou **encapsul√©**. Il est tout-√†-fait impossible d'y acc√©der d'un autre 
composant. 

Cependant, il est possible qu'un composant parent d√©cide de passer √† un composant enfant des informations des ses **props** ou de son **√©tat** 
via les **props** du composant enfant `<FormattedDate date={this.state.date}>` o√π ici, `this.state.date` correspond √† l'√©tat du composant 
parent.  
Le composant enfant va donc recevoir cette information, mais ne sera pas en capacit√© de savoir la nature de l'information. C'est-√†-dire 
si elle provient des **props**, de **l'√©tat** du composant parent ou bien encore si elle a √©t√© simplement tap√© √† la main. 

En reprennat l'id√©e de l'image du dessus, on appelle √ßa un flux de donn√©es "du haut vers le bas" ou "unidirection".  
Un √©tat local est toujours poss√©d√© uniquement par un composant sp√©cifique, et toute donn√©e ou UI d√©riv√©e de cet √©tat ne peut 
affecter que les composants descendants de celui-ci.

Dans une application React, le fait qu'un composant soit √† l'√©tat ou non est consid√©r√© comme un **d√©tail d'impl√©mentation** du 
composant qui peut varier avec le temps.  
Vous pouvez tr√®s bien utiliser un composant avec √©tat, √† l'int√©rieur d'un composant sans √©tat, et vice-versa. 

[**‚òù Retour en haut de page**](#-d√©couverte-de-react)
## G√©rer les √©v√©nements ([doc](https://fr.reactjs.org/docs/handling-events.html))

La gestion des √©v√©nements pour les √©l√©ments React poss√®de une synthaxe tr√®s proche de celle pour les √©l√©ments du DOM, √† quelques d√©tails 
pr√®s : 
1. les √©v√©nements de React sont nomm√©s en **camelCase** plut√¥t qu'en minuscule
2. En JSX on passe **une fonction** comme gestionnaire d'√©v√©nement plut√¥t qu'une cha√Æne de caract√®re

Ce qui donne : 
```
// HTML
<button onclick="doSomeThg()">
  Je r√©alise une action
</button>

// React
<button onClick={doSomeThg}>
  Je r√©alise aussi une action
</button>
```

Autre √©l√©ment qui √† son importance, en React nous ne pouvons pas `return false` pour emp√™cher le comportement par d√©faut d'un √©l√©ment HTML.  
Pour cela Il faut explicitement appeler `preventDefault()`.

```
// HTML
<a href="#" onclick="console.log('Le lien a √©t√© cliqu√©"); return false;">
  Clic !
</a>

// React
function ActionLink() {
  function handleClick(e) {
    e.prenventDefault();
    console.log('Le lien a √©t√© cliqu√©');
  }

  return (
    <a href="#" onClick={handleClick}>
      Clic !
    </a>
  )
}
```

Ici, `e` est ce que l'on appelle un [**√©v√©nement synth√©tique**](https://fr.reactjs.org/docs/events.html). React le d√©finit selon les normes 
W3C afin que nous n'ayions pas √† nous pr√©occuper de la compatibilit√© entre les navigateurs.  
Les √©v√©nements React ne fonctionnent pas tout √† fait comme les √©l√©ments natifs, il est donc conseill√© de creuser d'avantage leur fonctionnement 
en suivant le lien vers la documentation renseign√©e juste avant.

Lorsque l'on utilise React, nous n'aurons que tr√®s rarement besoin de l'appelle √† la m√©thode `addEventListener`.  
Tout simplement car nous passons l'ensemble des √©couteurs lors du rendu initial de l'√©l√©ment.

Lorsque l'on utilise les [**classes ES6**](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Classes) afin de d√©finir un 
composant, il est d'usage de faire en sorte que les gestionnaires d'√©v√©nements de ce composant soient des m√©thodes de la classe. 

```
class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isToggleOn: true }

    // On r√©alise une liaison entre la m√©thode et le mot-cl√© this
    // Cette √©tape est obligatoire pour permettre l'utilisation de this
    // dans la fonction de rappel
    this.handleClick = this.handleClick.bind(this)
  }

  handleClick() {
    this.setState(state => ({
      isToggleOn: !state.isToggleOn
    }))
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        {this.state.isToggleOn ? 'ON' : 'OFF'}
      </button>
    )
  }
}

ReactDOM.render(
  <Toggle />,
  document.getElementById('app-eventsClass')
)
```

En JSX il faut √™tre prudent avec l'usage de `this` au sein des fonctions de rappel.  
En effet, en JavaScript, nativement, les m√©thodes de classes ne sont pas li√©es par d√©faut.  
Si on oublie de lier, dans le constructeur, `this.handleClick` √† `this` √† l'aide de la fonction [`bind()`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)  
et qu'on l'utilise √† l'int√©rieur de la fonction de rappel alors `this` sera √©gale √† `undefined` quand la fonction sera appel√©e. 

Comme dit plus t√¥t, ce comportement n'est pas propre √† React, mais il provient bien d'une [**sp√©cificit√© des fonctions en JavaScript**](https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/).  
En g√©n√©ral, si nous faisons appelle √† une m√©thode sans `()` alors nous serons dans l'obligation de la lier avec `bind()`. 

Si nous ne voulons pas utiliser `bind()` il existe deux autres m√©thodes : 
1. l'utilisation de [**la syntaxe des champs de classes**](https://babeljs.io/docs/plugins/transform-class-properties/) (exp√©rimentale)
2. sinon en utilisant simplement les [**fonctions fl√©ch√©es**](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Functions/Arrow_functions) pour les fonctions de rappels

```
// 1 - champs de classes
class LoggingButton extends React.Component {
  // Cette syntaxe nous assure que `this` est bien li√© dans la m√©thode handleClick.
  // Attention : cette syntaxe est encore *exp√©rimentale*.
  handleClick = () => {
    console.log('this vaut :', this);
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        Clique ici
      </button>
    );
  }
}

// 2 - fonctions fl√©ch√©es dans les fonctions de rappels
class LoggingButton extends React.Component {
  handleClick() {
    console.log('this vaut :', this);
  }

  render() {
    // Cette syntaxe nous assure que `this` est bien li√© dans la m√©thode handleClick
    return (
      <button onClick={() => this.handleClick()}>
        Clique ici
      </button>
    );
  }
}
```

> ‚ùó Cependant, il faut faire tr√®s attention avec l'usage de la troisi√®me m√©thode. En effet, √† chaque rendu du composant une nouvelle 
> fonction de rappel sera cr√©√©e.  
> Dans la plus part des cas, ce n'est pas d√©rangeant, mais si nous passons cette fonction en props √† des composants plus bas dans l'arbre 
> ces composants risqueraient de forcer des r√©-affichages superflus du composant.  
> Il est donc d√©conseill√© d'utiliser cette troisi√®me m√©thode. 

### Passer des arguments √† un gestionnaire d'√©v√©nements

Au sein d'une boucle, qui it√©rerait par exemple jusqu'√† cr√©er toutes les lignes d'un tableau, il est courant de vouloir passer un 
argument suppl√©mentaire √† un gestionnaire d'√©v√©nement.  
Par exemple, si `id` ici repr√©sente l'ID de la ligne du tableau en question, nous pourrions imaginer d'√©crire le composant de ces 
deux mani√®res diff√©rentes : 

```
// 1 - Avec la fonction fl√©ch√©e
<button onClick={(e) => this.deleteRow(id, e)}></button>

// 2 - Avec la m√©thode bind()
<button onClick={this.deleteRow.bind(this, id)}></button>
```

Les lignes pr√©c√©dentes sont √©quivalentes et utilisent respectivement les **fonctions fl√©ch√©es** et **Function.Prototype.bind**.  
Dans les deux cas, l‚Äôargument e represente l‚Äô√©v√©nement React qui sera pass√© en second argument apr√®s l‚ÄôID. Avec une fonction fl√©ch√©e, nous devons passer l‚Äôargument explicitement, alors qu‚Äôavec bind tous les arguments sont automatiquement transmis.